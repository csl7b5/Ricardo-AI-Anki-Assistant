from __future__ import annotations

import os
import json
import base64
from typing import Any, Optional
from PyQt6.QtCore import QTimer, QUrl, Qt
from PyQt6.QtGui import QDesktopServices, QFont
from PyQt6.QtWidgets import (
    QDialog, QVBoxLayout, QLabel, QLineEdit, QDialogButtonBox, QMessageBox,
    QDockWidget, QWidget, QHBoxLayout, QPushButton, QComboBox, QSpinBox, QTextEdit
)

from aqt import mw
from aqt.webview import AnkiWebView
from aqt.operations import QueryOp
from aqt.utils import showWarning, tooltip

from .openai_client import chat
from .card_context import current_card_context

DEFAULT_SYSTEM_PROMPT = (
    "You are Ricardo, an advanced Anki study assistant designed to be both comprehensive and efficient.\n"
    "Your goal is to provide high-yield explanations that deepen understanding without being overwhelming.\n"
    "CONTEXT: You will be given the current flashcard context (question + answer + fields + optional images).\n"
    "INSTRUCTIONS:\n"
    "1. **Content**: Prioritize exam-relevant details, mechanisms, and clinical correlations. Do not be overly brief if important nuance is lost.\n"
    "2. **Structure**: Use **bold** for key terms, bullet points for lists, and Markdown tables for comparisons or classifications.\n"
    "3. **Tone**: succinct but thorough. Avoid conversational fluff. Focus on what the user needs to know for their exams. This includes pathology, mechanisms, high-yield vignettes, and any relevant management plans/algorithms.\n"
    "Include any links to relevant information from trusted sources such as Bootcamp, Pixorize, Medbullets, Boards and Beyond, Sketchy, or any research articles.\n"
    "Unless it is super relevant, don't give things that the user doesn't ask for explicitly.\n"
    "You may be expected to answer general questions (give all relevant information), mnemonics, Step-1/Step-2 style example questions, or tables/lists."
)

# HTML Template with Flexbox Layout & Markded.js for CSR
CHAT_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Inject Marked.js from CDN for robust markdown parsing -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {
            --bg-color: #F5F2EB;
            --text-color: #343541;
            --user-bubble: #EBEAE4;
            --ai-bubble: #FFFFFF;
            --ai-border: #E5E7EB;
            --accent: #C69F7A;
        }
        body {
            font-family: 'Georgia', serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            font-size: 14px;
            line-height: 1.6;
        }
        /* Flexbox Layout for Bubbles */
        .message-row {
            display: flex;
            margin-bottom: 20px;
            width: 100%;
            flex-direction: column;
        }
        .message-row.user {
            align-items: flex-end;
        }
        .message-row.ai {
            align-items: flex-start;
        }
        
        /* Role Header (Outside Bubble) */
        .role-label {
            font-weight: bold;
            font-size: 13px;
            margin-bottom: 6px;
            color: var(--text-color);
        }
        .user .role-label {
            text-align: right;
            margin-right: 4px;
        }
        .ai .role-label {
            text-align: left;
            color: var(--accent); /* Ricardo accent */
            margin-left: 4px;
        }

        /* Bubble Styling */
        .bubble {
            padding: 14px 20px;
            border-radius: 12px;
            max-width: 85%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            word-wrap: break-word;
        }
        .user .bubble {
            background-color: var(--user-bubble);
            border-bottom-right-radius: 2px;
        }
        .ai .bubble {
            background-color: var(--ai-bubble);
            border: 1px solid var(--ai-border);
            border-bottom-left-radius: 2px;
        }

        /* Intro Styling */
        .intro-message {
            text-align: center;
            margin-bottom: 30px;
            color: #6b7280;
            font-style: italic;
            font-size: 15px;
        }

        /* Markdown Styles (Generated by Marked.js) */
        p { margin: 0 0 10px 0; }
        p:last-child { margin-bottom: 0; }
        strong { font-weight: 600; }
        em { font-style: italic; }
        h1, h2, h3, h4 { margin-top: 15px; margin-bottom: 8px; color: #111827; font-weight: bold; }
        ul, ol { margin: 5px 0 5px 20px; padding: 0; }
        li { margin-bottom: 4px; }
        code { background: #f3f4f6; padding: 2px 4px; border-radius: 4px; font-family: monospace; font-size: 12px; }
        pre { background: #1f2937; color: #f9fafb; padding: 10px; border-radius: 6px; overflow-x: auto; }
        blockquote { border-left: 3px solid var(--accent); padding-left: 10px; color: #6b7280; font-style: italic; }

        /* Table Styles (Robust) */
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
            font-size: 13px;
            table-layout: auto;
            background-color: #fff;
        }
        th, td {
            border: 1px solid #d1d5db;
            padding: 10px 14px;
            text-align: left;
            vertical-align: top;
        }
        th {
            background-color: #f3f4f6;
            font-weight: bold;
            color: #111827;
        }
        tr:nth-child(even) {
            background-color: #f9fafb;
        }

        /* Loading Spinner */
        #loading-container {
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px 0;
        }
        .spinner-img {
            width: 48px;
            height: 48px;
            object-fit: contain;
            animation: spin 1.5s linear infinite;
        }
        @keyframes spin { 
            100% { transform: rotate(360deg); } 
        }
        .loading-text {
            margin-top: 10px;
            color: #6b7280;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="intro-message">
        <strong>Hi! I'm Ricardo, your Anki cards assistant.</strong><br>
        Ask me a question about your current card!
    </div>

    <div id="chat-container"></div>
    
    <div id="loading-container">
        <img id="spinner-logo" src="" class="spinner-img" alt="Loading..." />
        <span class="loading-text">Thinking...</span>
    </div>

    <script>
        // Configure Marked.js
        marked.setOptions({
            gfm: true, // GitHub Flavored Markdown (Tables!)
            breaks: true, // Line breaks as <br>
            headerIds: false,
            mangle: false
        });

        const chatContainer = document.getElementById('chat-container');
        const loadingContainer = document.getElementById('loading-container');
        const spinnerLogo = document.getElementById('spinner-logo');

        function appendMessage(role, rawMarkdown) {
            const row = document.createElement('div');
            row.className = `message-row ${role}`;
            
            const roleName = role === 'user' ? 'You' : 'Ricardo';
            const roleDiv = document.createElement('div');
            roleDiv.className = 'role-label';
            roleDiv.textContent = roleName;
            
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // USE MARKED.JS TO PARSE MARKDOWN
            contentDiv.innerHTML = marked.parse(rawMarkdown);
            
            bubble.appendChild(contentDiv);
            row.appendChild(roleDiv);
            row.appendChild(bubble);
            chatContainer.appendChild(row);
            
            scrollToBottom();
            return contentDiv;
        }

        let currentStreamDiv = null;

        function startStreaming() {
            // Create a new AI message row with empty content
            currentStreamDiv = appendMessage('ai', '');
        }

        function updateStreaming(rawMarkdown) {
            if (currentStreamDiv) {
                // Re-render the markdown as it streams in
                // Marked is fast enough for small chunks
                currentStreamDiv.innerHTML = marked.parse(rawMarkdown);
                scrollToBottom();
            }
        }
        
        function setLoading(visible, logoBase64) {
            loadingContainer.style.display = visible ? 'flex' : 'none';
            if (visible && logoBase64) {
                spinnerLogo.src = logoBase64;
                spinnerLogo.style.display = 'block';
            } else if (visible && !spinnerLogo.src) {
                spinnerLogo.style.display = 'none';
            }
            scrollToBottom();
        }

        function scrollToBottom() {
            window.scrollTo(0, document.body.scrollHeight);
        }
    </script>
</body>
</html>
"""

class ChatEntry(QLineEdit):
    """Custom QLineEdit that traps Enter key events to prevent Anki shortcuts."""
    def keyPressEvent(self, event):
        if event.key() in (Qt.Key.Key_Return, Qt.Key.Key_Enter):
            # Emit returnPressed manually
            self.returnPressed.emit()
            # Accept event to stop propagation to Anki main window
            event.accept()
            return
        super().keyPressEvent(event)

class APIKeyDialog(QDialog):
    """Dialog to prompt user for OpenAI API Key."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Ricardo Setup: OpenAI API Key")
        self.setMinimumWidth(400)
        
        layout = QVBoxLayout(self)
        
        # Instructions
        instr = QLabel(
            "<h3>Welcome to Ricardo!</h3>"
            "<p>To use this add-on, you need an OpenAI API Key.</p>"
            "<ol>"
            "<li>Go to <a href='https://platform.openai.com/account/api-keys'>OpenAI API Keys</a>.</li>"
            "<li>Create a new secret key.</li>"
            "<li>Paste it below.</li>"
            "</ol>"
        )
        instr.setOpenExternalLinks(True)
        instr.setWordWrap(True)
        layout.addWidget(instr)
        
        # Input
        self.key_input = QLineEdit()
        self.key_input.setPlaceholderText("sk-...")
        self.key_input.setEchoMode(QLineEdit.EchoMode.Password)
        layout.addWidget(self.key_input)
        
        # Buttons
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(self.validate_and_save)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)
        
    def validate_and_save(self):
        key = self.key_input.text().strip()
        if not key.startswith("sk-"):
            QMessageBox.warning(self, "Invalid Key", "The key should start with 'sk-'. Please check and try again.")
            return
        
        self.accept()

    def get_key(self):
        return self.key_input.text().strip()

class SettingsDialog(QDialog):
    """Dialog for configuring Ricardo settings."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Ricardo Settings")
        self.setMinimumWidth(500)
        self.resize(500, 600)

        layout = QVBoxLayout(self)

        # Config Helper
        self._cfg = mw.addonManager.getConfig(__name__.split('.')[0]) or {}

        # 1. API Key
        layout.addWidget(QLabel("<b>OpenAI API Key:</b>"))
        self.api_key_input = QLineEdit()
        self.api_key_input.setPlaceholderText("sk-...")
        self.api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_key_input.setText(self._cfg.get("api_key", ""))
        layout.addWidget(self.api_key_input)

        # 2. Model
        layout.addWidget(QLabel("<b>Model:</b>"))
        self.model_combo = QComboBox()
        self.model_combo.setEditable(True)  # Allow user to type any future model name
        self.model_combo.addItems([
            "gpt-5-mini", 
            "gpt-4o-mini", 
            "o3-mini", 
            "gpt-5.2", 
            "gpt-5", 
            "gpt-4o"
        ])
        current_model = self._cfg.get("model", "gpt-5-mini") # Default to efficient modern model
        self.model_combo.setCurrentText(current_model)
        layout.addWidget(self.model_combo)

        # 3. System Prompt
        layout.addWidget(QLabel("<b>System Prompt (Personality):</b>"))
        self.system_prompt_input = QTextEdit()
        self.system_prompt_input.setPlaceholderText("Customize Ricardo's behavior...")
        self.system_prompt_input.setPlainText(self._cfg.get("system_prompt", DEFAULT_SYSTEM_PROMPT))
        layout.addWidget(self.system_prompt_input)

        # 4. Max Images
        layout.addWidget(QLabel("<b>Max Images (0-10):</b>"))
        self.max_images_spin = QSpinBox()
        self.max_images_spin.setRange(0, 10)
        self.max_images_spin.setValue(int(self._cfg.get("max_images", 2)))
        layout.addWidget(self.max_images_spin)
        
        # 5. Timeout
        layout.addWidget(QLabel("<b>Timeout (Seconds):</b>"))
        self.timeout_spin = QSpinBox()
        self.timeout_spin.setRange(10, 600)
        self.timeout_spin.setValue(int(self._cfg.get("timeout_seconds", 60)))
        layout.addWidget(self.timeout_spin)

        # Buttons
        buttons = QDialogButtonBox(QDialogButtonBox.StandardButton.Save | QDialogButtonBox.StandardButton.Cancel)
        buttons.accepted.connect(self.save_settings)
        buttons.rejected.connect(self.reject)
        layout.addWidget(buttons)

    def save_settings(self):
        # Update config dictionary
        self._cfg["api_key"] = self.api_key_input.text().strip()
        self._cfg["model"] = self.model_combo.currentText()
        self._cfg["system_prompt"] = self.system_prompt_input.toPlainText()
        self._cfg["max_images"] = self.max_images_spin.value()
        self._cfg["timeout_seconds"] = self.timeout_spin.value()

        # Save to disk
        mw.addonManager.writeConfig(__name__.split('.')[0], self._cfg)
        tooltip("Settings saved!")
        self.accept()

class ChatWebView(AnkiWebView):
    """Custom WebView for the Chat Interface."""
    def __init__(self, parent: QWidget):
        super().__init__(parent=parent)

class CustomTitleBar(QWidget):
    """A pretty, custom title bar for the dock."""
    def __init__(self, parent: QDockWidget):
        super().__init__(parent)
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 8, 10, 8)
        
        # Title Label
        self.title = QLabel("Ricardo")
        font = QFont("Georgia", 14, QFont.Weight.Bold)
        self.title.setFont(font)
        self.title.setStyleSheet("color: #343541; border: none;")
        layout.addWidget(self.title)
        
        layout.addStretch()

class ChatDock(QDockWidget):
    default_area = Qt.RightDockWidgetArea

    def __init__(self, parent: QWidget):
        super().__init__("Ricardo", parent)
        self.setObjectName("anki_chatgpt_sidebar_dock")
        self.setFeatures(QDockWidget.DockWidgetFeature.DockWidgetMovable | 
                        QDockWidget.DockWidgetFeature.DockWidgetFloatable |
                        QDockWidget.DockWidgetFeature.DockWidgetClosable)

        self.title_bar = CustomTitleBar(self)
        self.setTitleBarWidget(self.title_bar)
        
        self._cfg = mw.addonManager.getConfig(__name__.split('.')[0]) or {}

        # Check API Key on startup (delayed)
        QTimer.singleShot(100, self._check_api_key)

        # State
        self._typing_timer = QTimer(self)
        self._typing_timer.setInterval(30)
        self._typing_timer.timeout.connect(self._on_typing_tick)
        self._target_message = ""
        self._typing_index = 0
        self._logo_base64 = self._load_logo_base64()

        # UI Layout
        root = QWidget(self)
        root.setStyleSheet("background-color: #F5F2EB;")
        self.setWidget(root)

        layout = QVBoxLayout(root)
        layout.setContentsMargins(15, 20, 15, 15)
        layout.setSpacing(10)

        # WebView (The Chat)
        self.web = ChatWebView(self)
        self.web.stdHtml(CHAT_TEMPLATE, context=None)
        layout.addWidget(self.web, 1)

        # Input Area - USE CUSTOM ChatEntry
        row = QHBoxLayout()
        self.input = ChatEntry() # Changed from QLineEdit()
        self.input.setPlaceholderText("Message...")
        self.input.setStyleSheet("""
            QLineEdit {
                padding: 10px;
                border: 1px solid #D1D5DB;
                border-radius: 8px;
                background-color: #FFFFFF;
                color: #343541;
                font-family: 'Helvetica', 'Arial', sans-serif;
                font-size: 13px;
            }
            QLineEdit:focus {
                border: 1px solid #343541;
            }
        """)
        
        self.send_btn = QPushButton("Send")
        self.send_btn.setCursor(Qt.CursorShape.PointingHandCursor)
        self.send_btn.setStyleSheet("""
            QPushButton {
                padding: 10px 18px;
                background-color: #C69F7A;
                color: white;
                border: none;
                border-radius: 8px;
                font-weight: bold;
                font-family: 'Helvetica', 'Arial', sans-serif;
            }
            QPushButton:hover {
                background-color: #B08D69;
            }
            QPushButton:pressed {
                background-color: #9A7B5C;
            }
        """)
        
        row.addWidget(self.input, 1)
        row.addWidget(self.send_btn)
        layout.addLayout(row)

        self.send_btn.clicked.connect(self._on_send)
        self.input.returnPressed.connect(self._on_send)

    def focus_input(self) -> None:
        self.input.setFocus()

    def open_settings_dialog(self):
        dialog = SettingsDialog(self)
        dialog.exec()

    def _check_api_key(self):
        """Checks for valid API key and prompts if missing."""
        key = self._cfg.get("api_key", "").strip()
        # More robust check: must start with sk- (or sk-proj for new ones)
        if not key or not key.startswith("sk-"):
            # Show Setup Dialog
            dialog = APIKeyDialog(self)
            if dialog.exec():
                new_key = dialog.get_key()
                self._cfg["api_key"] = new_key
                # Save config
                mw.addonManager.writeConfig(__name__.split('.')[0], self._cfg)
                tooltip("API Key saved successfully!")
            else:
                showWarning("Ricardo requires an OpenAI API key to function correctly.")

    def _load_logo_base64(self) -> Optional[str]:
        addon_dir = os.path.dirname(__file__)
        logo_filename = "sporo-health-high-resolution-logo-black-transparent.png"
        logo_path = os.path.join(addon_dir, logo_filename)
        
        if not os.path.exists(logo_path):
             logo_path = os.path.join(addon_dir, "sporo_logo_loading.png")
             
        if os.path.exists(logo_path):
            try:
                with open(logo_path, "rb") as f:
                    data = f.read()
                    b64 = base64.b64encode(data).decode('ascii')
                    return f"data:image/png;base64,{b64}"
            except Exception:
                pass
        return None

    def _append_user_message(self, text: str):
        # Send raw text to JS, let marked.js render it
        json_text = json.dumps(text)
        self.web.eval(f"appendMessage('user', {json_text});")

    def _start_ai_streaming(self, text: str):
        self._target_message = text
        self._typing_index = 0
        self.web.eval("startStreaming();") # Setup empty div
        self._typing_timer.start()

    def _on_typing_tick(self):
        chunk_size = 5
        if self._typing_index < len(self._target_message):
            self._typing_index += chunk_size
            current_text = self._target_message[:self._typing_index]
            
            # Send raw Markdown to JS for re-rendering
            json_text = json.dumps(current_text)
            self.web.eval(f"updateStreaming({json_text});")
        else:
            self._typing_timer.stop()

    def _set_loading(self, visible: bool):
        b64 = self._logo_base64 if self._logo_base64 else ""
        js_b64 = json.dumps(b64)
        js_bool = "true" if visible else "false"
        self.web.eval(f"setLoading({js_bool}, {js_b64});")

    def _cfg_val(self, key: str, default: Any) -> Any:
        self._cfg = mw.addonManager.getConfig(__name__.split('.')[0]) or {}
        return self._cfg.get(key, default)

    def _on_send(self) -> None:
        question = self.input.text().strip()
        if not question:
            return
        self.input.clear()
        
        self._append_user_message(question)
        self._set_loading(True)

        api_key = (self._cfg_val("api_key", "") or "").strip()
        if not api_key or "PASTE_" in api_key:
            # Re-prompt if they cancelled before or cleared it
            self._check_api_key()
            # Reload from config
            api_key = (self._cfg_val("api_key", "") or "").strip()
            if not api_key or "PASTE_" in api_key:
                self._set_loading(False)
                return

        model = self._cfg_val("model", "gpt-4.1-mini")
        timeout_seconds = int(self._cfg_val("timeout_seconds", 60))

        def build_payload():
            max_images = int(self._cfg_val("max_images", 2))
            max_image_bytes = int(self._cfg_val("max_image_bytes", 200000))

            ctx = current_card_context(max_images=max_images, max_image_bytes=max_image_bytes)
            if ctx is None:
                return f"User question (no card):\n{question}\n"

            fields_text = "\n".join([f"- {k}: {v}" for k, v in ctx.fields])
            images_text = ""
            if ctx.images:
                parts = []
                for fn, b64 in ctx.images:
                    parts.append(f"[Image: {fn}]\nBASE64:\n{b64}\n")
                images_text = "\n\n".join(parts)

            payload = (
                f"Card context:\n"
                f"Deck: {ctx.deck}\n"
                f"Note type: {ctx.note_type}\n\n"
                f"Rendered question (text):\n{ctx.question_text}\n\n"
                f"Rendered answer (text):\n{ctx.answer_text}\n\n"
                f"Raw note fields:\n{fields_text}\n"
            )
            if images_text:
                payload += f"\n\nAttached images:\n{images_text}\n"
            payload += f"\n\nUser question:\n{question}\n"
            return payload

        def op_fn(_):
            try:
                user_payload = build_payload()
            except Exception:
                user_payload = question
            
            system_prompt = self._cfg_val("system_prompt", DEFAULT_SYSTEM_PROMPT)

            return chat(
                api_key=api_key,
                model=model,
                system=system_prompt,
                user=user_payload,
                timeout_seconds=timeout_seconds,
            )

        def on_success(answer: str):
            self._set_loading(False)
            self._start_ai_streaming(answer)

        def on_err(e: Exception):
            self._set_loading(False)
            showWarning(str(e))

        QueryOp(parent=mw, op=op_fn, success=on_success).run_in_background()
